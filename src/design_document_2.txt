			+---------------------------+
			|		CS 330				|
			| PROJECT 2: USER PROGRAMS	|
			| 	   DESIGN DOCUMENT     	|
			+---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

HyungJun Yoon <diamond264@kaist.ac.kr>
SangHyun Lee <leesh6796@kaist.ac.kr>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
따로 만든 struct나 global, static 변수는 없습니다.
start_process 내에 char *args_addr[100] 변수를 만들어서 args[i]의 SP를 저장하는 용도로 사용했습니다.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?
Argument passing은 총 두 곳에서 일어났습니다. process_execute와 start_process.
process_execute에서는 arguments 중 file name만 필요하기 때문에 strtok_r 한 번의 실행으로 원하는 부분을 얻어낼 수 있습니다.
start_process와의 race condition을 피하기 위해 주어진 fn_name을 복사한 다음, strtok_r로 filename을 분리해 thread를 create합니다.

start_process에서는 strtok_r을 통해 argument를 파싱한 뒤, stack에는 역순으로 집어넣습니다. 이는 strtok_r의 실행순서에 맞게 자연스럽게
argument를 push하기 위함입니다. argv[1], argv[2], … 순서로 stack에 넣었다면, 이들의 주소는 원래 순서대로
&argv[n], &argv[n-1], … , &argv[1]의 순서로 삽입합니다. 실제 argument에의 접근은 포인터로 이뤄지기 때문에 실제 데이터의 삽입 순서는 고려되지 않습니다.
처음에는 snprintf를 통해 임시 메모리 공간에 역순대로 정렬한 뒤, 삽입하려 했지만, 후에 버그를 잡는 과정에서 이 절차를 삭제하고 원래 순서대로 넣는 방법을 채택했습니다.
esp address를 validate 하는 과정은 argument passing 과정이 아닌, system call function에서 argument를 뽑아내는 과정에서 이뤄졌습니다. 이 때 argument의 address가 valid한 영역에 있는지, NULL은 아닌지 등을 검사합니다.
스택 오버플로우는 체크하지 않았습니다.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?
전역 변수를 사용하지 않고 스택 안에서만 탐색을 한다.
병렬 실행을 보장하기에, Thread-safe한 특성을 가진다.
따라서 thread, multi-thread, signal handler에서 이용할 시 안전하다.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.
UNIX System은 argument tokenizing을 다른 Thread에서 진행하는 것처럼 만들어준다(Shell에서 진행하기 때문에). 이는 priority가 높은 thread가 실행되어야 할 때 tokenizing thread가 yield 될 수 있다는 것을 의미하고, priority scheduling이 새롭게 만들어지는 thread에 영향을 받지 않고 안정적으로 실행될 수 있다는 것을 의미한다.
또한, 쉘이 tokenizing을 담당하기 때문에 커널의 물리적 코드가 줄어든다. (커널 복잡도 하락)

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
struct thread
  {
    /* Owned by thread.c. */
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[16];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int priority;                       /* Priority. */
    int64_t terminate_sleep;            /* ticks for sleep */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

    /* Edited : Variables for donation */
    struct list acquired_locks;
    struct list lost_locks;
    struct lock *locked;
    int real_priority;
    struct thread *donated;
    struct semaphore *sema_block;

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /* Page directory. */

    int exit_status;
    int child_exit_status;
    struct thread *parent;
    struct list children;
    int next_fd;

    struct semaphore sema_start;
    struct semaphore sema_exit;

    struct list files;
    struct file *program; // executable file을 저장.
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */
  };
File 입출력 관련 system call에서 synchronization을 위한 lock을 설정하였다.
struct lock file_lock으로 정의하였으며, read와 write시 사용한다.
thread에 open된 파일들을 관리하기 위하여 구조체 안에 files list를 만들었다.
Open system call에서 list에 push되며 close될 때 remove하여 준다.
또한 이와 같이 file들을 list에 넣어 관리하기 위하여 element로 만들어 주었는데,
struct file_elem {
  struct file *file;
  int fd;
  struct list_elem elem;
};
과 같이 fd와 file자체를 가질 수 있도록 설정하였다.
또한 file마다 고유의 fd값이 존재해야하는데, 이는 thread에서 next_fd라는 구조를 추가하여 해결하였다.
0과 1은 파일 입출력 관련이기에, thread가 initiate될 때 next_fd를 2로 초기화 시킨 후
syscall_open이 호출될 때 마다 값을 증가시키며 file에 fd를 붙여 주었다.
wait밑 exec과 관련한 부분에서는 thread간의 child관계를 확인할 필요가 있기에, thread구조체 안에
Children list를 만들어 관리하였다. 이 안에는 thread들의 tid와 exit status, load의 성공 여부 및
exit의 성공 여부를 나타내는 element가 들어간다.
struct child_elem {
  tid_t tid;
  char *name;
  bool terminated;
  bool loaded;
  int exit_status;
  struct list_elem elem;
};


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?
앞에서 언급했듯이 한 thread안에서 next_fd란 변수를 조정하며 fd값을 붙여 준다.
이는 thread가 open될 때 마다 변하므로 한 파일에 대하여 해당 fd값은 유일하다.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.
우선 주어진 buffer의 주소값이 유효한지를 검사한다.
read의 경우 fd값이 1을 제외한 숫자여야 한다. (1은 write)
0일 경우 이는 input을 받는 것을 의미하는데, input_getc를 이용하여 size만큼 input을 받는다.
return값은 size가 된다.
0이 아닐 경우 thread의 files에서 fd값의 file을 찾는 get_file을 이용하여 파일을 가져오고
file_read(찾은 파일, buffer, size)를 통하여 해당 값을 return하도록 했다.
이러한 작업 앞뒤로 lock을 걸어 다른 read/write가 일어나지 못하도록 한다.
write의 경우 반대로 fd값이 0이면 안되며, 1일 경우 putbuf를 통하여 buffer 에 size만큼의 데이터를 저장한다.
그 외의 숫자일 경우 read와 같은 과정을 거치되 file_write를 이용한다.
마찬가지로 lock을 통하여 read와 write의 접근을 제한한다.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?
페이지의 크기가 4096byte이기에, 최대 두 개의 페이지에 allocate될 수 있다.
따라서 최대 두 개의 페이지에 접근하여 pagedir_get_page()를 호출하여 주면 된다.
2byte data의 경우에도 마찬가지이다. 

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.
process_wait에서 주된 과정을 implement하였다.
thread의 semaphore sema_exit 이 exit과 wait 사이의 synchronization을 관리하여 준다.
만약 wait child를 호출하였는데 child가 없을 경우 -1을 return,
child가 종료되지 않고 정상적으로 기다릴 수 있을 경우는 child의 죽음을 기다려 exit될 시 
exit_status를 return한다. (이후 child elem이 필요 없으므로 list에서 제거한다.)
child가 먼저 종료된 경우, child의 죽음을 기다릴 필요가 없다.
child가 종료될 시 exit status는 parent의 children list에 child_elem 으로서 저장되는데,
이를 통하여 wait을 부르는 thread에서는 return값을 알 수 있다.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.
process.c의 validate_addr 함수가 그 역할을 한다.
해당 address이 null일 경우, kernel 영역일 경우, page를 받아올 수 없을 경우
exit(-1)을 통하여 종료시키는 방법이다.
또한 load가 잘못되었을 시 exit하는 부분은 exception.c에서 검사를 하여 exit시켜주는 방식을 선택하였다.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?
start에서 load의 상태를 알 수 있는 방법이 기존 thread에는 없었다.
이를 방지하기 위하여 process_execute와 start_process간의 synchronization을 관리하는
sema_start와 함께 child_elem에 load 성공 여부를 따지는 loaded 변수를 추가하였다.
이는 start_process에서 load가 성공할 때만 true로 바뀌어, execute시 이 변수를 통하여
검사를 하면 load가 성공적으로 된 thread인지 알 수 있다.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?
첫 번째로, c가 exit되기 전에 wait이 선언될 경우 sema_exit을 down시켜 c가 exit을 완료할 때까지
기다린다. exit 내부에서 thread의 parent의 sema_exit이 down되어 있을 경우 up을 시켜주어 wait 내부로
다시 들어갈 수 있게 한다.
c가 먼저 exit된 경우 semaphore을 down시키면 up을 해주지 않아 실행을 멈추게 된다.
따라서 semaphore을 건들지 않고, exit될 시 child_elem에 exit_status 를 저장하여 이를 
wait에서 참조할 수 있도록 한다. 참조가 끝나면 remove해준다. (Resource free)
Execute시 load가 잘 되지 않은 child_elem을 free하기도 하였다.
다른 경우는 고려하지 않았다.

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?
process.c의 validate_addr 함수가 그 역할을 한다.
필요한 곳에서 validate_addr를 매번 하는 방식이 번거롭기는 하지만, pointer를 이용하는
(검증이 필요한) 모든 곳에서 사용을 했기에 safe한 것으로 보인다.
load가 되지 않아 kill로 들어가는 경우 kill함수를 implement하여 같은 역할을 하도록 했다.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?
Advantage : thread마다 정보를 가지고 있기 때문에 thread가 exit될 시 list를 한번에 free시키면
해당 file들의 메모리 관리를 한번에 할 수 있다.
스레드 정보를 가지고 file에 접근할 때 빠르게 접근할 수 있다.

Disadvantage : thread 정보를 모를 경우 tid를 찾아야 하기에 O(n)의 시간이 걸린다.
(thread검색 시간 + file검색 시간)

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?
한 프로세스 안에 single thread가 있으므로 pid개념을 따로 사용하지 않고 tid개념을 그대로 사용하였다.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?